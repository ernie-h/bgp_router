#!/usr/bin/env python3
""" Skeleton Implementation of Project 2 for NEU CS3700 """

import argparse
import json
import select
import socket
import copy
import ipaddress
##########################################################################################

# Message Fields
TYPE = "type"
SRCE = "src"
DEST = "dst"
MESG = "msg"
TABL = "table"

# Message Types
DATA = "data"
DUMP = "dump"
UPDT = "update"
RVKE = "revoke"
NRTE = "no route"

# Update Message Fields
NTWK = "network"
NMSK = "netmask"
ORIG = "origin"
LPRF = "localpref"
APTH = "ASPath"
SORG = "selfOrigin"

# internal route info
CUST = "cust"
PEER = "peer"
PROV = "prov"


##########################################################################################

class Router:
  """ Your Router """
  def __init__(self, asn, networks):
    self.routes = {}
    self.updates = {}
    self.relations = {}
    self.sockets = {}
    print (networks)
    self.ftab = []
    self.announcements=[]
    self.revocations = []
    self.asn = asn

    for relationship in networks:
      network, relation = relationship.split("-")
      self.sockets[network] = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
      self.sockets[network].setblocking(0)
      self.sockets[network].connect(network)
      self.relations[network] = relation

 # TODO: For now compares the first prefix of the ip 
  def similar_network(self, n1, n2):
    n1_split = n1.split('.')
    n2_split = n2.split('.')
    return n1_split[0] == n2_split[0]
  
  def lookup_routes(self, daddr):
    """ Lookup all valid routes for an address """
    print("FORWARDING TABLE ", self.ftab)
    outroutes = []
    for entry in self.ftab:
        if self.similar_network(entry['network'], daddr):
            outroutes.append(entry['peer'])
    return outroutes

  def get_shortest_as_path(self, routes, daddr):
    """ select the route with the shortest AS Path """
    outroutes = []
    min = 0
    for route in routes:
      for e in self.ftab: 
        if e[PEER] == route and self.similar_network(e[NTWK], daddr):
          if len(e[APTH]) == min:
            outroutes.append(route)
          elif len(e[APTH]) < min or len(outroutes) == 0:
            min = len(e[APTH])
            outroutes = [route]
    return outroutes

  def get_highest_preference(self, routes, daddr):
    """ select the route with the highest "localpref" """
    # TODO
    outroutes = []
    max = 0
    for route in routes:
      for e in self.ftab:
        if e[PEER] == route and self.similar_network(e[NTWK], daddr):
          if e[LPRF] == max and route not in outroutes:
            outroutes.append(route)
          elif e[LPRF] > max:
            max = e[LPRF]
            outroutes = [route]
    return outroutes
    
  def get_self_origin(self, routes, daddr):
    """ select self originating routes """
    outroutes = []
    all_false = True
    for route in routes:
      for e in self.ftab:
        if e[PEER] == route and self.similar_network(e[NTWK], daddr):
            if e[SORG]:
                outroutes.append(route)
                all_false= False
            elif all_false:
                return routes
    return outroutes

  def get_origin_routes(self, routes, daddr):
    """ select origin routes: EGP > IGP > UNK """
    outroutes = []
    origins = {"IGP": 1,"EGP": 2,"UNK": 3}
    origin = 3
    for route in routes:
      for e in self.ftab:
        if e[PEER] == route and self.similar_network(e[NTWK], daddr):
          if origins[e[ORIG]] < origin:
            origin = origins[e[ORIG]]
            outroutes = [route]
          elif origins[e[ORIG]] == origin:
            outroutes.append(route)
    return outroutes 

  def filter_relationships(self, srcif, daddr, routes):
    """ Don't allow Peer->Peer, Peer->Prov, or Prov->Peer forwards """
    outroutes = []
    src_relation = self.relations[srcif]
    # source or destination router is a customer => foward data
    # source is peer or provider => forward if dest is customer
    for route in routes:
      dest_relation = self.relations[route]
      if dest_relation == CUST:
        outroutes.append(route)
      elif src_relation == CUST:
        outroutes.append(route)
      else:
        return []
    return outroutes
  
  def cust_only(x):
      return self.relations[x] == PEER or self.relations[x] == PROV

  #def get_highest_prefix(self, daddr, routes):
   # netmaskLength = 

  def get_route(self, srcif, daddr):
    """ Select the best route for a given address """
    # TODO
    peer = None
    routes = self.lookup_routes(daddr)
    print("ROUTES AFTER LOOKUP ROUTES:", routes)
    # routes = self.get_highest_prefix(routes)
    # Rules go here
    if routes:
      # 1. Highest Preference
      routes = self.get_highest_preference(routes, daddr)
      # 2. Self Origin
      print("ROUTES FOR HIGHEST PREF", routes)
      routes = self.get_self_origin(routes, daddr)
      print("ROUTES FOR self origin", routes)
      # 3. Shortest ASPath
      routes = self.get_shortest_as_path(routes, daddr)
      print("ROUTES FOR ASPATH", routes)
      # 4. IGP > EGP > UNK
      routes = self.get_origin_routes(routes, daddr)
      print("ROUTES FOR ORIGIN", routes)
      # 5. Lowest IP Address
      routes = [min(routes)] 
      print("ROUTES FOR LOWEST IP", routes)
      # Final check: enforce peering relationships
      print("RELATIONS", self.relations)
      routes = self.filter_relationships(srcif, daddr, routes)
    if (len(routes) == 1):
        peer = routes[0]
        print("ROUTES IS OF LENGTH 1")
    else:
        print("ERROR MORE THAN 1 ROUTE", routes) 
    return self.sockets[peer] if peer else None

  def forward(self, srcif, packet):
    """ Forward a data packet """
    route = self.get_route(srcif, packet[DEST])
    if route:
        route.sendall(json.dumps(packet).encode())
        print("FORWARDED PACKET TO: ", route) 
        print('\n')
        return True
    else:
        packet[TYPE] =  "no route"
        packet[MESG] = {}
        packet[DEST] = packet[SRCE]
        packet[SRCE] = ('.').join(srcif.split('.', 3)[:3]) + '.1'
        self.sockets[srcif].sendall(json.dumps(packet).encode())
        return False

  def coalesce(self):
    """ coalesce any routes that are right next to each other """
    # TODO (this is the most difficult task, save until last)
    return False

  def update(self, srcif, packet):
    """ handle update packets """
    # TODO: figure out forwarding table structure 
    self.ftab.append({
        'network': packet[MESG][NTWK], 
        'netmask': packet[MESG][NMSK], 
        'peer': packet[SRCE],
        'localpref': packet[MESG][LPRF],
        'ASPath': packet[MESG][APTH],
        'origin': packet[MESG][ORIG],
        'selfOrigin': packet[MESG][SORG]
        }) 
    # TODO: Might need to store announcments as updated for this router
    self.announcements.append(packet)
    src_relationship = self.relations[srcif]
    for socket in self.sockets:
      newPacket = copy.deepcopy(packet)
      newSource = ('.').join(socket.split('.', 3)[:3]) + '.1'
      newPacket[SRCE] = newSource
      newPacket[DEST] = socket
      newPacket[MESG][APTH].append(int(self.asn))
      dest_relationship = self.relations[socket]
      if src_relationship == CUST:
        if(socket != srcif):
          self.sockets[socket].sendall(json.dumps(newPacket).encode())
          print("ROUTE ANNOUNCMENT TO "+ socket +": ", newPacket)
      elif dest_relationship == CUST:
        self.sockets[socket].sendall(json.dumps(newPacket).encode())
        print("ROUTE ANNOUNCMENT TO "+ socket +": ", newPacket)
    return True

  def revoke(self, packet):
    """ handle revoke packets """
    # save copy of revocation
    self.revocations.append(packet)
    
    # remove dead entry from forwarding table
    for network in packet[MESG]:
      for entry in self.ftab:
        if packet[SRCE] == entry[PEER] and entry[NTWK] == network[NTWK] and entry[NMSK] == network[NMSK]:
          self.ftab.remove(entry)

    # send copies of revocation to neighbors
    newPacket = copy.deepcopy(packet)
    # update received from customer -> send updates to all neighbors
    # update received from peer/provider -> send updates to customers
    relationToMessageSender = self.relations[packet[SRCE]]
    if relationToMessageSender == CUST:
      # send to all neighbors
      for socket in self.sockets:
        if (socket != packet[SRCE]):
            newSource = ('.').join(socket.split('.', 3)[:3]) + '.1'
            newPacket[SRCE] = newSource
            newPacket[DEST] = socket
            self.sockets[socket].sendall(json.dumps(newPacket).encode())
            print("REVOKE ANNOUNCMENT TO "+ socket +": ", newPacket)
    elif relationToMessageSender == PEER or relationToMessageSender == PROV:
      # send to all customers
      for socket in self.sockets:
        relationToSocket == self.relations[socket]
        if relationToSocket == CUST:
            newSource = ('.').join(socket.split('.', 3)[:3]) + '.1'
            newPacket[SRCE] = newSource
            newPacket[DEST] = socket
            self.sockets[socket].sendall(json.dumps(newPacket).encode())
            print("REVOKE ANNOUNCMENT TO "+ socket +": ", newPacket)
    return True

  def dump(self, packet):
    """ handles dump table requests """
    # TODO
    response = {}
    response[SRCE] = packet[DEST]
    response[DEST] = packet[SRCE]
    response[TYPE] = TABL
    response[MESG] = self.ftab
    self.sockets[packet[SRCE]].sendall(json.dumps(response).encode())
    print("TABLE MSG SENT: ", response)  
    return True
  
  def handle_packet(self, srcif, packet):
    """ dispatches a packet """
    # TODO
    t = packet['type']
    if(t == UPDT):
        return self.update(srcif, packet)
    elif(t == DATA):
        print("Received data msg")
        return self.forward(srcif, packet)    
    elif(t == DUMP):
        print("Received dump msg")
        return self.dump(packet)
    elif(t == RVKE):
        print("Received revoke msg")
        return self.revoke(packet)
    else:
        return False

  def send_error(self, conn, msg):
    """ Send a no_route error message """
    # TODO
    return
	
  def run(self):
    """ main loop for the router """
    while True:
      socks = select.select(self.sockets.values(), [], [], 0.1)[0]
      for conn in socks:
        try:
          k = conn.recv(65535)
        except:
          # either died on a connection reset, or was SIGTERM's by parent
          return
        if k:
          for sock in self.sockets:
            if self.sockets[sock] == conn:
              srcif = sock
          msg = json.loads(k)
          if not self.handle_packet(srcif, msg):
            self.send_error(conn, msg)
        else:
          return

if __name__ == "__main__":
  PARSER = argparse.ArgumentParser(description='route packets')
  PARSER.add_argument('asn')
  PARSER.add_argument('networks', metavar='networks', type=str, nargs='+', help="networks")
  ARGS = PARSER.parse_args()
  Router(ARGS.asn, ARGS.networks).run()

